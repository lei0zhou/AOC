# AOC 2024

## AOC helper

```elixir
defmodule AOCHelper do
  def to_int_list(txt_file) do
    txt_file
    |> File.read!()
    |> String.split("\n", trim: true)
    |> Enum.map(fn list ->
      String.split(list) |> Enum.map(&String.to_integer/1)
    end)
  end
end
```

```elixir
# defmodule Day do
#   @file_path "/Users/leizhou/Dev/learn_x/aoc/2024/day.txt"
#   def part1 do
#   end

#   def part2 do
#   end
# end

# IO.inspect(%{day_part1: Day.part1()})
# IO.inspect(%{day_part2: Day.part2()})
```

## Day 1

```elixir
day1_file = "/Users/leizhou/Dev/learn_x/aoc/2024/day1.txt"

[group_1, group_2] =
  day1_file
  |> AOCHelper.to_int_list()
  |> Enum.reduce([[], []], fn [num1, num2], [group1, group2] ->
    [[num1 | group1], [num2 | group2]]
  end)
  |> Enum.map(&Enum.sort/1)

[group_1, group_2]
|> Enum.zip()
|> Enum.reduce(0, fn elements, acc ->
  acc + abs(elem(elements, 0) - elem(elements, 1))
end)
|> IO.inspect(label: "day1 part1")

count_map = Enum.frequencies(group_2)

Enum.reduce(group_1, 0, fn num, acc ->
  acc + num * Map.get(count_map, num, 0)
end)
|> IO.inspect(label: "day1 part2")
```

## Day 2

```elixir
defmodule Day2 do
  @file_path "/Users/leizhou/Dev/learn_x/aoc/2024/day2.txt"

  def check_sign(list), do: Enum.all?(list, fn x -> x >= 0 end) or Enum.all?(list, fn x -> x <= 0 end)

  def check_abs(list), do: Enum.all?(list, fn x -> abs(x) >= 1 and abs(x) <= 3 end)

  def check_cond(list), do: check_sign(list) and check_abs(list)

  def diff_report(list) do
    Enum.reduce(Enum.zip([list, tl(list)]), [], fn {prev, current}, acc ->
      [current - prev | acc]
    end)
  end

  def part1_check(list) do
    list
    |> diff_report()
    |> check_cond()
  end

  def part1() do
    @file_path
    |> AOCHelper.to_int_list()
    |> Enum.map(fn list ->
      part1_check(list)
    end)
    |> Enum.frequencies()
  end

  def part2_check(list) do
    1..length(list)
    |> Enum.map(fn index ->
      List.delete_at(list, index - 1)
      |> part1_check()
    end)
    |> Enum.any?()
  end

  def part2() do
    @file_path
    |> AOCHelper.to_int_list()
    |> Enum.map(fn list ->
      part2_check(list)
    end)
    |> Enum.frequencies()
  end
end

%{day2_part1: Day2.part1(), day2_part2: Day2.part2()}
```

## Day 3

```elixir
defmodule Day3 do
  @file_path "/Users/leizhou/Dev/learn_x/aoc/2024/day3.txt"

  def part1 do
    @file_path
    |> File.read!()
    |> then(fn string -> Regex.scan(~r/mul\((?<num1>\d{1,3}),(?<num2>\d{1,3})\)/, string) end)
    |> Enum.reduce(0, fn [_, num_string1, num_string2], acc ->
      acc + String.to_integer(num_string1) * String.to_integer(num_string2)
    end)
  end

  def make_instruct_map(text) do
    map_do =
      Regex.scan(~r/do\(\)/, text, return: :index)
      |> Enum.reduce(%{}, fn [{index, _}], acc ->
        Map.put(acc, index, 1)
      end)

    map_not =
      Regex.scan(~r/don't\(\)/, text, return: :index)
      |> Enum.reduce(%{}, fn [{index, _}], acc ->
        Map.put(acc, index, 0)
      end)

    Map.merge(map_do, map_not) |> Map.put(0, 1)
  end

  def make_instruct_index_list(map_instruct) do
    Map.keys(map_instruct) |> Enum.sort()
  end

  def make_mul_index_list(text) do
    text
    |> then(fn string ->
      Regex.scan(~r/mul\((?<num1>\d{1,3}),(?<num2>\d{1,3})\)/, string, return: :index)
    end)
    |> Enum.reduce([], fn [{index, _}, _, _], acc ->
      [index | acc]
    end)
    |> Enum.reverse()
  end

  def make_mul_number_list(text) do
    text
    |> then(fn string -> Regex.scan(~r/mul\((?<num1>\d{1,3}),(?<num2>\d{1,3})\)/, string) end)
    |> Enum.reduce([], fn [_, num_string1, num_string2], acc ->
      [String.to_integer(num_string1) * String.to_integer(num_string2) | acc]
    end)
    |> Enum.reverse()
  end

  def make_instuct_ind_list(mul_index_list, list_instruct_index, map_instruct) do
    mul_index_list
    |> Enum.map(fn index ->
      Enum.reduce_while(list_instruct_index, nil, fn instruct_index, acc ->
        if index - instruct_index > 0, do: {:cont, instruct_index}, else: {:halt, acc}
      end)
      |> then(fn index -> Map.get(map_instruct, index) end)
    end)
  end

  def calculate_sum(instruct_ind_list, mul_number_list) do
    Enum.zip(instruct_ind_list, mul_number_list)
    |> Enum.reduce(0, fn {ind, num}, acc ->
      acc + ind * num
    end)
  end

  def process_text(text) do
    [make_instruct_map(text), make_mul_index_list(text), make_mul_number_list(text)]
  end

  def part2 do
    text = File.read!(@file_path)

    [map_instruct, mul_index_list, mul_number_list] = process_text(text)

    list_instruct_index = make_instruct_index_list(map_instruct)

    instruct_ind_list = make_instuct_ind_list(mul_index_list, list_instruct_index, map_instruct)

    calculate_sum(instruct_ind_list, mul_number_list)
  end
end

IO.inspect(%{day3_part1: Day3.part1()})
IO.inspect(%{day3_part2: Day3.part2()})
```

```elixir

```
